{"ast":null,"code":"// create a store\n// create a ruducer\n// then dont subscribe though we will \n// import {createStore} from 'redux'\nimport { createSlice, configureStore } from '@reduxjs/toolkit'; // import redux from 'redux'\n\nconst initialCounterState = {\n  counter: 0,\n  fullName: 'Wallie R.',\n  toggle: true\n}; // call create slice , and store it somewhere\n\nconst counterSlice = createSlice({\n  // every state slice needs a name\n  name: 'counter',\n  initialState: initialCounterState,\n  // we need to set the initial state by passing the initial \n  // we already create up top\n  // then we need to add reducers to all the reducers this state slice needs \n  reducers: {\n    // now 4 methods because we have 4 different if cases before \n    // all method will receive the current state \n    increment(state) {\n      // your allowed to mutate the state, will internally return the clone state and get back a new state object even though it looks like a its mutating the state \n      state.counter++;\n    },\n\n    decrease(state) {\n      state.counter--;\n    },\n\n    // if we need data thats attached ot the action we can accept it as a argument\n    increase(state, action) {\n      // state.counter = state.counter + action.payload.num//if we pass in an object\n      state.counter = state.counter + action.payload; //if we pass in an object\n    },\n\n    toggleCounter(state) {\n      state.toggle = !state.toggle;\n    }\n\n  }\n});\nconst initialLoginState = {\n  isAuthenticated: false\n};\ncreateSlice({\n  name: 'authentication',\n  initialState: initialLoginState,\n  red\n}); // const countReducer = (state, action)=>{\n//     if(action.type === 'increment'){\n//         return {...state, counter :state.counter + 1}\n//     }else if(action.type === 'decrement'){\n//         return {...state, counter :state.counter - 1}\n//     }else if(action.type === 'increase'){\n//         return {...state,counter :state.counter + action.amount}\n//     }else if(action.type === 'toggle'){\n//         return {...state,toggle: !state.toggle}\n//     }\n//     return state\n// }\n// either way it just depends how u import it at the top, we destructured the method out of redux\n// const store = redux.createStore(countReducer, initial)\n// const store = createStore(countReducer, initial)\n// because of this we dont have to worry about coming up with different action types or identifiers \n// this actions property will hold all of our methods and we can dispatch them as we please\n// counterSlice.actions.toggleCounter this will be out dispatch to trigger different actions \n\nconst store = configureStore({\n  reducer: counterSlice.reducer //if only one this is fine \n  //if multiple \n  // reducer:{counter:counterSlice.reducer, etc:etc}//basically a map of reducers\n\n}); // we need ot export this to provide the store to the react app \n\nexport const countActions = counterSlice.actions; //so we can dispatch actions\n\nexport default store; // now where do we import our store to use it","map":{"version":3,"names":["createSlice","configureStore","initialCounterState","counter","fullName","toggle","counterSlice","name","initialState","reducers","increment","state","decrease","increase","action","payload","toggleCounter","initialLoginState","isAuthenticated","red","store","reducer","countActions","actions"],"sources":["/Volumes/Wallies Extreme SSD/VscodeWorkspaceSSD/VstudioCode/ReactPractice/ReactPart18(ReduxRealAppPart8ReduxToolkitMultiState)/01-starting-project 5/src/store/index.js"],"sourcesContent":["// create a store\n// create a ruducer\n// then dont subscribe though we will \n// import {createStore} from 'redux'\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\n// import redux from 'redux'\n\nconst initialCounterState = {counter:0, fullName:'Wallie R.', toggle:true}\n\n// call create slice , and store it somewhere\nconst counterSlice = createSlice({\n    // every state slice needs a name\n    name:'counter',\n    initialState: initialCounterState, // we need to set the initial state by passing the initial \n    // we already create up top\n    // then we need to add reducers to all the reducers this state slice needs \n    reducers:{\n        // now 4 methods because we have 4 different if cases before \n        // all method will receive the current state \n        increment(state){\n            // your allowed to mutate the state, will internally return the clone state and get back a new state object even though it looks like a its mutating the state \n            state.counter++;\n        },\n        decrease(state){\n            state.counter--\n        },\n        // if we need data thats attached ot the action we can accept it as a argument\n        increase(state, action){\n            // state.counter = state.counter + action.payload.num//if we pass in an object\n            state.counter = state.counter + action.payload//if we pass in an object\n        },\n        toggleCounter(state){\n           state.toggle = !state.toggle\n        }\n    }\n})\n\nconst initialLoginState = {\n    isAuthenticated : false\n}\n\ncreateSlice({\n    name:'authentication',\n    initialState: initialLoginState,\n    red\n})\n\n// const countReducer = (state, action)=>{\n//     if(action.type === 'increment'){\n//         return {...state, counter :state.counter + 1}\n//     }else if(action.type === 'decrement'){\n//         return {...state, counter :state.counter - 1}\n//     }else if(action.type === 'increase'){\n//         return {...state,counter :state.counter + action.amount}\n//     }else if(action.type === 'toggle'){\n//         return {...state,toggle: !state.toggle}\n//     }\n//     return state\n// }\n\n// either way it just depends how u import it at the top, we destructured the method out of redux\n// const store = redux.createStore(countReducer, initial)\n// const store = createStore(countReducer, initial)\n\n// because of this we dont have to worry about coming up with different action types or identifiers \n// this actions property will hold all of our methods and we can dispatch them as we please\n// counterSlice.actions.toggleCounter this will be out dispatch to trigger different actions \n\nconst store = configureStore({\n    reducer: counterSlice.reducer//if only one this is fine \n    //if multiple \n    // reducer:{counter:counterSlice.reducer, etc:etc}//basically a map of reducers\n})\n\n// we need ot export this to provide the store to the react app \nexport const countActions = counterSlice.actions//so we can dispatch actions\nexport default store;\n// now where do we import our store to use it"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAT,EAAsBC,cAAtB,QAA4C,kBAA5C,C,CACA;;AAEA,MAAMC,mBAAmB,GAAG;EAACC,OAAO,EAAC,CAAT;EAAYC,QAAQ,EAAC,WAArB;EAAkCC,MAAM,EAAC;AAAzC,CAA5B,C,CAEA;;AACA,MAAMC,YAAY,GAAGN,WAAW,CAAC;EAC7B;EACAO,IAAI,EAAC,SAFwB;EAG7BC,YAAY,EAAEN,mBAHe;EAGM;EACnC;EACA;EACAO,QAAQ,EAAC;IACL;IACA;IACAC,SAAS,CAACC,KAAD,EAAO;MACZ;MACAA,KAAK,CAACR,OAAN;IACH,CANI;;IAOLS,QAAQ,CAACD,KAAD,EAAO;MACXA,KAAK,CAACR,OAAN;IACH,CATI;;IAUL;IACAU,QAAQ,CAACF,KAAD,EAAQG,MAAR,EAAe;MACnB;MACAH,KAAK,CAACR,OAAN,GAAgBQ,KAAK,CAACR,OAAN,GAAgBW,MAAM,CAACC,OAAvC,CAFmB,CAE2B;IACjD,CAdI;;IAeLC,aAAa,CAACL,KAAD,EAAO;MACjBA,KAAK,CAACN,MAAN,GAAe,CAACM,KAAK,CAACN,MAAtB;IACF;;EAjBI;AANoB,CAAD,CAAhC;AA2BA,MAAMY,iBAAiB,GAAG;EACtBC,eAAe,EAAG;AADI,CAA1B;AAIAlB,WAAW,CAAC;EACRO,IAAI,EAAC,gBADG;EAERC,YAAY,EAAES,iBAFN;EAGRE;AAHQ,CAAD,CAAX,C,CAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA,MAAMC,KAAK,GAAGnB,cAAc,CAAC;EACzBoB,OAAO,EAAEf,YAAY,CAACe,OADG,CACI;EAC7B;EACA;;AAHyB,CAAD,CAA5B,C,CAMA;;AACA,OAAO,MAAMC,YAAY,GAAGhB,YAAY,CAACiB,OAAlC,C,CAAyC;;AAChD,eAAeH,KAAf,C,CACA"},"metadata":{},"sourceType":"module"}